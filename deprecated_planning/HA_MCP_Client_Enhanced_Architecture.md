# Home Assistant MCP Client Architecture

**Author:** Generated by AI Assistant  
**Date:** February 13, 2026  
**Status:** Architecture Planning Document

---

## Executive Summary

**The fundamental insight:** Home Assistant already has excellent LLM integration capabilities (Ollama, OpenAI, Anthropic, etc.) that allow AI agents to control HA via the **Assist API**. However, there is **no MCP client component** in Home Assistant that would allow the voice assistant to call external MCP servers.

**What you need:** Not a full MCP client framework, but rather **integration with the Assist API to leverage MCP server capabilities** when your voice assistant processes queries.

**The best approach:** Augment existing HA LLM/integration framework to optionally call MCP servers for additional tools/knowledge, using MCP as a plugin mechanism rather than replacing existing functionality.

---

## Current State Analysis

### What Already Exists in Home Assistant

1. **MCP Server Integration** (`mcp_server`)
   - Exposes HA to external MCP clients
   - Allows external tools to control HA
   - **Direction**: External → HA
   - URL: `/api/mcp` (SSE transport)

2. **LLM Conversation Integrations** (Ollama, OpenAI, etc.)
   - Handle AI conversations within HA
   - Use Assist API to expose devices and entities
   - Support tool calling for HA functionality
   - **Direction**: HA ↔ LLM
   - **But**: No support for calling external MCP servers

3. **Assist API** (The key integration point)
   - Provides entity access control
   - Manages device/service exposure
   - Handles intent recognition
   - **Perfect bridge point for MCP integration**

### The Gap

| Direction | Status | Description |
|-----------|--------|-------------|
| **MCP Client → HA** (what you want) | ❌ Missing | HA calling external MCP servers |
| **HA → MCP Server** | ✅ Complete | External tools calling HA via mcp_server |
| **LLM → HA** | ✅ Complete | AI conversation agents have HA access |

---

## Recommended Architecture

### Approach: Assist API Extension with MCP Fallback

Instead of building a full MCP client infrastructure, we should **extend the existing Assist API and LLM integration framework** to optionally query MCP servers when:

1. HA's native capabilities are insufficient
2. MCP servers provide additional tools/knowledge
3. User explicitly configures MCP server connections

### Why This Approach?

✅ **Leverages existing robust infrastructure**  
✅ **No duplicate conversation management**  
✅ **Single point for entity exposure control**  
✅ **Fits HA's architectural patterns**  
✅ **Lower development/maintenance burden**

---

## Implementation Plan

### Phase 1: MCP Fallback Integration (MVP)

#### 1. Configuration System

**New HA Integration**: `mcp_assist_client`

```yaml
# Example: Configuring MCP servers as Assist fallbacks
mcp_assist_client:
  enabled: true
  servers:
    - server_id: "mcp_tools"
      transport: "sse"
      url: "https://mcp.example.com/api"
      auth_token: !secret mcp_api_token
      # Optional: Only use when native HA fails
      fallback_only: true
      # Optional: Specific tools to expose to HA
      tools:
        - weather_forecast
        - news_headlines
      # Optional: Specific tools to block
      blocked_tools:
        - system_commands
    
    - server_id: "mcp_knowledge"
      transport: "websocket"
      url: "ws://localhost:8080/mcp"
      auth_token: !secret mcp_ws_token
      # Always use these tools
      always_use: true
      tools:
        - documentation_lookup
        - code_snippets
```

#### 2. Integration Points

**Modify `/homeassistant/components/assistant/conversation.py`**

Current flow:
```
User Query → STT → NLU → Intent Execution → TTS
```

**New flow with MCP**:
```
User Query → STT → NLU → [Native HA Check] → [MCP Fallback Check] → Intent Execution → TTS
                    ↓
              If native HA tools insufficient
                    ↓
              Query MCP servers for additional tools
                    ↓
              Combine results and generate response
```

**Pseudocode:**

```python
# In conversation.py

class ConversationProcessor:
    async def process(self, text, context):
        # 1. Try native HA intent recognition
        result = await self._try_native_intent(text)
        
        if result.success or not self.mcp_fallback_enabled:
            return result
        
        # 2. Fall back to MCP servers
        mcp_results = await self._query_mcp_servers(text)
        
        # 3. Combine results
        combined = self._combine_results(result, mcp_results)
        
        # 4. Generate response
        return await self._generate_response(combined, context)
    
    async def _query_mcp_servers(self, text):
        """Query configured MCP servers for additional tools"""
        results = []
        
        for server in self.mcp_servers:
            try:
                # Get available tools from MCP server
                tools = await server.list_tools()
                
                # Select relevant tools based on query
                relevant_tools = self._select_relevant_tools(tools, text)
                
                # Call selected tools
                tool_results = []
                for tool in relevant_tools:
                    args = self._extract_arguments(text, tool)
                    result = await server.call_tool(tool.name, args)
                    tool_results.append(result)
                
                results.append({
                    'server_id': server.id,
                    'tools': tool_results
                })
                
            except Exception as e:
                logger.error(f"MCP server {server.id} failed: {e}")
                continue
        
        return results
```

#### 3. MCP Client Transport Layer

```python
# transport layer for MCP connections

import asyncio
from abc import ABC, abstractmethod

class MCPTransport(ABC):
    @abstractmethod
    async def connect(self):
        pass
    
    @abstractmethod
    async def disconnect(self):
        pass
    
    @abstractmethod
    async def list_tools(self):
        pass
    
    @abstractmethod
    async def call_tool(self, name: str, arguments: dict):
        pass


class SSETransport(MCPTransport):
    """Server-Sent Events transport for MCP"""
    
    def __init__(self, url: str, auth_token: str = None):
        self.url = url
        self.auth_token = auth_token
        self.session = None
        self.event_source = None
    
    async def connect(self):
        headers = {}
        if self.auth_token:
            headers['Authorization'] = f'Bearer {self.auth_token}'
        
        self.session = aiohttp.ClientSession(headers=headers)
        self.event_source = aiohttp_sse.ClientSession(self.url)
        await self.event_source.connect()
    
    async def disconnect(self):
        if self.event_source:
            await self.event_source.close()
        if self.session:
            await self.session.close()
    
    async def list_tools(self):
        # SSE message: get tools
        await self.event_source.send("mcp/tools/list")
        response = await self.event_source.read()
        return response.tools
    
    async def call_tool(self, name: str, arguments: dict):
        # SSE message: call tool
        payload = {
            "tool": name,
            "arguments": arguments
        }
        await self.event_source.send("mcp/tools/call", payload)
        return await self.event_source.read()
```

---

## Security Architecture

### 1. Credential Management

**Best Practice: Use Home Assistant's Secret Manager**

```python
# In config_flow.py
class MCPConfigFlow(config_entries.ConfigFlow):
    async def async_step_user(self, user_input=None):
        if user_input is not None:
            # Store credentials in HA secret manager
            secret_id = f"mcp_{self.server_id}"
            secret_value = user_input['auth_token']
            
            # Use HA's secret manager
            await self.hass.config.async_update(
                path="mcp_clients",
                server_id=self.server_id,
                secret=secret_id
            )
            
            # Use persistent notification to store secret
            await self.hass.services.async_call(
                "secret", "set", {
                    "secret_id": secret_id,
                    "secret_value": secret_value
                }
            )
```

### 2. Transport Security

**Enforce TLS for remote connections:**

```python
class TransportSecurityValidator:
    """Validate transport security configurations"""
    
    @staticmethod
    def validate_url(url: str, is_remote: bool) -> bool:
        """Enforce HTTPS for remote, localhost for local"""
        if is_remote:
            # Must be HTTPS
            if not url.startswith('https://'):
                raise ValueError("Remote MCP servers must use HTTPS")
            # Certificate validation
            # TODO: Add certificate verification
        
        # Local connections can use HTTP
        if not is_remote and not url.startswith(('http://localhost', 'http://127.0.0.1')):
            raise ValueError("Local MCP servers must use localhost/127.0.0.1")
        
        return True
```

### 3. Input Validation

**Sanitize all inputs:**

```python
import re

class InputSanitizer:
    """Sanitize inputs to prevent injection attacks"""
    
    # Allow only safe characters in tool names and arguments
    SAFE_TOOL_NAME_PATTERN = re.compile(r'^[a-zA-Z0-9_-]+$')
    SAFE_ARGUMENT_PATTERN = re.compile(r'^[a-zA-Z0-9_\-\.\s:<>]+$')
    
    @classmethod
    def validate_tool_name(cls, name: str) -> bool:
        """Validate tool name format"""
        return bool(cls.SAFE_TOOL_NAME_PATTERN.match(name))
    
    @classmethod
    def sanitize_argument(cls, value: str) -> str:
        """Sanitize argument values"""
        # Remove potentially dangerous characters
        # Limit length
        # Validate format
        sanitized = cls.SAFE_ARGUMENT_PATTERN.sub('', value)
        return sanitized[:255]  # Limit to 255 chars
```

### 4. Rate Limiting & Circuit Breakers

```python
from asyncio import Semaphore
from time import time

class MCPRateLimiter:
    """Rate limit MCP server calls"""
    
    def __init__(self, max_calls: int = 10, window_seconds: int = 60):
        self.max_calls = max_calls
        self.window_seconds = window_seconds
        self.calls = []
        self.semaphore = Semaphore(max_calls)
    
    async def acquire(self):
        """Acquire permission to make a call, waiting if necessary"""
        async with self.semaphore:
            now = time()
            
            # Remove old calls outside the window
            self.calls = [t for t in self.calls if now - t < self.window_seconds]
            
            if len(self.calls) >= self.max_calls:
                # Wait until oldest call expires
                oldest = min(self.calls)
                wait_time = self.window_seconds - (now - oldest)
                if wait_time > 0:
                    await asyncio.sleep(wait_time)
                    return await self.acquire()
            
            self.calls.append(now)
```

---

## Error Handling & Degradation

### 1. Graceful Degradation

```python
class MCPFallbackHandler:
    """Handle MCP fallback with graceful degradation"""
    
    def __init__(self, mcp_servers: list):
        self.servers = mcp_servers
        self.failed_servers = set()
        self.consecutive_failures = {}
    
    async def query_server(self, server_id: str, query: str):
        """Query MCP server with failure tracking"""
        if server_id in self.failed_servers:
            logger.debug(f"Skipping failed server: {server_id}")
            return None
        
        try:
            result = await self._query_server_internal(server_id, query)
            
            # Reset failure counter on success
            self.consecutive_failures[server_id] = 0
            return result
            
        except Exception as e:
            logger.error(f"MCP server {server_id} failed: {e}")
            
            # Track failures
            self.consecutive_failures[server_id] = \
                self.consecutive_failures.get(server_id, 0) + 1
            
            # Mark server as failed after threshold
            if self.consecutive_failures[server_id] >= 3:
                self.failed_servers.add(server_id)
                logger.warning(f"Server {server_id} marked as failed after {self.consecutive_failures[server_id]} failures")
            
            return None
```

### 2. Timeout Management

```python
class MCPTimeoutManager:
    """Manage timeouts for MCP operations"""
    
    DEFAULT_TIMEOUTS = {
        'connection': 10,      # seconds to establish connection
        'tool_execution': 60,  # seconds to execute tool
        'response': 30,        # seconds to receive response
    }
    
    def __init__(self, timeouts: dict = None):
        self.timeouts = {**self.DEFAULT_TIMEOUTS, **(timeouts or {})}
    
    async def execute_with_timeout(self, coro, operation: str):
        """Execute coroutine with timeout"""
        timeout = self.timeouts.get(operation, 30)
        try:
            return await asyncio.wait_for(coro, timeout=timeout)
        except asyncio.TimeoutError:
            logger.error(f"MCP {operation} timed out after {timeout}s")
            raise
```

---

## Testing Strategy

### 1. Unit Tests

```python
# tests/components/mcp_assist_client/test_transport.py
import pytest
from homeassistant.components.mcp_assist_client.transport import SSETransport

@pytest.mark.asyncio
async def test_sse_transport_connect(mock_aiohttp_client):
    """Test SSE transport connection"""
    transport = SSETransport(
        url="http://localhost:8080/mcp",
        auth_token="test_token"
    )
    
    await transport.connect()
    assert transport.is_connected
    assert transport.session is not None

@pytest.mark.asyncio
async def test_sse_transport_call_tool(mock_server):
    """Test tool calling via SSE"""
    transport = SSETransport(
        url="http://localhost:8080/mcp",
        auth_token="test_token"
    )
    
    await transport.connect()
    result = await transport.call_tool("get_weather", {"location": "home"})
    
    assert "weather" in result
    assert result["location"] == "home"
```

### 2. Integration Tests

```python
# tests/components/mcp_assist_client/test_integration.py

async def test_assist_fallback_to_mcp(hass):
    """Test that Assist falls back to MCP for unhandled requests"""
    
    # Configure MCP server
    await setup_mcp_server(hass, {
        'server_id': 'test_mcp',
        'transport': 'sse',
        'url': 'http://localhost:8080/mcp'
    })
    
    # Native HA doesn't handle this
    native_result = await hass.services.async_call(
        'conversation', 'process', {'text': 'What is the weather?'}
    )
    
    # Should fall back to MCP
    mcp_result = await get_mcp_response('What is the weather?')
    
    assert mcp_result is not None
    assert 'weather' in mcp_result.lower()
```

### 3. Security Tests

```python
# tests/components/mcp_assist_client/test_security.py

async def test_input_sanitization():
    """Test that inputs are properly sanitized"""
    from homeassistant.components.mcp_assist_client.security import InputSanitizer
    
    # Test tool name sanitization
    dangerous_name = "tool_name<script>"
    sanitized = InputSanitizer.sanitize_tool_name(dangerous_name)
    assert '<' not in sanitized
    assert '>' not in sanitized
    
    # Test argument sanitization
    dangerous_arg = "value' OR 1=1 --"
    sanitized = InputSanitizer.sanitize_argument(dangerous_arg)
    assert "'" not in sanitized
    assert '--' not in sanitized
```

---

## Migration Path

### From Custom MCP Server to HA Native

If you wanted to use the `allenporter/mcp-server-home-assistant` custom component:

**Current setup:**
1. Install custom component
2. Configure MCP server
3. Connect external clients

**Future native setup:**
1. Use HA's native `mcp_assist_client` integration
2. Configure MCP servers directly in HA
3. HA voice assistant automatically uses MCP as fallback

**Migration path:**
- Existing users can continue with custom component
- Native integration provides better voice assistant integration
- Gradual migration over time

---

## Dependencies

### Required

```python
# requirements_all.txt
mcp>=1.0.0
aiohttp>=3.9
aiohttp-sse>=1.0
pydantic>=2.0
```

### Optional

```python
# For enhanced functionality
websockets>=12  # WebSocket transport
docker>=7.0     # Container-based MCP servers
prometheus_client>=0.20  # Metrics
```

---

## Configuration Options

### Full Options Example

```yaml
mcp_assist_client:
  enabled: true
  servers:
    - server_id: "mcp_tools"
      transport: "sse"
      url: "https://mcp.example.com/api"
      auth_token: !secret mcp_api_token
      fallback_only: true
      timeout:
        connection: 10
        execution: 60
        response: 30
      tools:
        - weather_forecast
        - news_headlines
      blocked_tools:
        - system_commands
      
    - server_id: "mcp_knowledge"
      transport: "websocket"
      url: "ws://localhost:8080/mcp"
      auth_token: !secret mcp_ws_token
      always_use: true
      timeout:
        connection: 5
        execution: 30
        response: 15
      tools:
        - documentation_lookup
        - code_snippets
```

---

## Performance Considerations

### 1. Async Processing

All MCP operations use `async/await` to avoid blocking HA:

```python
async def process_mcp_queries(text: str):
    """Process MCP queries asynchronously"""
    tasks = []
    
    for server in mcp_servers:
        tasks.append(asyncio.create_task(query_server(server, text)))
    
    # Run all queries concurrently
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # Process results
    for result in results:
        if isinstance(result, Exception):
            logger.error(f"MCP query failed: {result}")
        else:
            process_result(result)
```

### 2. Caching

```python
from functools import lru_cache
import time

class MCPResponseCache:
    """Cache MCP responses to reduce calls"""
    
    def __init__(self, ttl: int = 300):  # 5 minute TTL
        self.ttl = ttl
        self.cache = {}
    
    def get(self, key: str):
        """Get cached response if valid"""
        if key in self.cache:
            cached_time, value = self.cache[key]
            if time.time() - cached_time < self.ttl:
                return value
            else:
                del self.cache[key]
        return None
    
    def set(self, key: str, value):
        """Cache a response"""
        self.cache[key] = (time.time(), value)
```

---

## Monitoring & Logging

### Structured Logging

```python
import structlog

logger = structlog.get_logger()

async def query_mcp_server(server_id: str, query: str):
    """Query MCP server with structured logging"""
    
    logger.info(
        "mcp_query_start",
        server_id=server_id,
        query_length=len(query),
        timestamp=time.time()
    )
    
    try:
        result = await _perform_query(server_id, query)
        
        logger.info(
            "mcp_query_success",
            server_id=server_id,
            result_length=len(result),
            duration=time.time() - start_time
        )
        
        return result
        
    except Exception as e:
        logger.error(
            "mcp_query_failure",
            server_id=server_id,
            error=str(e),
            error_type=type(e).__name__
        )
        raise
```

### Metrics

```python
from prometheus_client import Counter, Histogram

# Metrics
MCP_QUERIES_TOTAL = Counter(
    'mcp_queries_total',
    'Total MCP queries',
    ['server_id', 'status']
)

MCP_QUERY_DURATION = Histogram(
    'mcp_query_duration_seconds',
    'MCP query duration',
    ['server_id']
)

MCP_FAILURES_TOTAL = Counter(
    'mcp_failures_total',
    'Total MCP failures',
    ['server_id', 'error_type']
)
```

---

## Security Checklist

- [ ] All HTTPS connections use proper certificate validation
- [ ] Credentials stored in HA secret manager
- [ ] Input sanitization for all user-provided values
- [ ] Rate limiting on MCP server calls
- [ ] timeouts on all operations
- [ ] Circuit breakers for failed servers
- [ ] Audit logging for all MCP interactions
- [ ] No debug output in production
- [ ] Error messages don't expose sensitive details
- [ ] Transport security enforced for all connections

---

## Conclusion

**The recommended approach** is to **extend the existing Assist API and LLM integration framework** to optionally query MCP servers, rather than building a full MCP client from scratch.

This approach:
- ✅ Leverages existing HA infrastructure
- ✅ Integrates naturally with voice assistant
- ✅ Minimizes development/maintenance burden
- ✅ Follows HA's architectural patterns
- ✅ Provides graceful fallback behavior

**Next steps:**
1. Implement Phase 1: MCP Fallback Integration
2. Add MCP transport (SSE/WebSocket) layer
3. Extend Assist API to query MCP servers
4. Test with MCP servers
5. Document configuration and usage

---

## Related Resources

- [Home Assistant MCP Server Documentation](https://www.home-assistant.io/integrations/mcp_server/)
- [Home Assistant Ollama Integration](https://www.home-assistant.io/integrations/ollama/)
- [Home Assistant OpenAI Integration](https://www.home-assistant.io/integrations/openai_conversation/)
- [Model Context Protocol Specification](https://modelcontextprotocol.io/)
- [home-llm Custom Component](https://github.com/acon96/home-llm) - Shows existing LLM integration patterns
